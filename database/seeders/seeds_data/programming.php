<?php

return [
    ['question' => 'Inheritance', 'answer' => 'Наследование', 'weight' => 0],
    ['question' => 'Encapsulation', 'answer' => 'Инкапсуляция', 'weight' => 0],
    ['question' => 'Polymorphism', 'answer' => 'Полиморфизм', 'weight' => 0],
    ['question' => 'Abstraction', 'answer' => 'Абстракция', 'weight' => 0],
    ['question' => 'Query', 'answer' => 'Запрос', 'weight' => 0],
    ['question' => 'Foreign Key', 'answer' => 'Внешний ключ', 'weight' => 0],
    ['question' => 'Constraint', 'answer' => 'Ограничение', 'weight' => 0],
    ['question' => 'Join', 'answer' => 'Соединение', 'weight' => 0],
    ['question' => 'View', 'answer' => 'Представление', 'weight' => 0],
    ['question' => 'Deadlock', 'answer' => 'Взаимная блокировка', 'weight' => 0],
    ['question' => 'Design Pattern', 'answer' => 'Шаблон проектирования', 'weight' => 0],
    ['question' => 'Singleton Pattern', 'answer' => 'Шаблон одиночка', 'weight' => 0],
    ['question' => 'Factory Pattern', 'answer' => 'Фабричный метод', 'weight' => 0],
    ['question' => 'Observer Pattern', 'answer' => 'Шаблон наблюдатель', 'weight' => 0],
    ['question' => 'Decorator Pattern', 'answer' => 'Шаблон декоратор', 'weight' => 0],
    ['question' => 'Strategy Pattern', 'answer' => 'Шаблон стратегия', 'weight' => 0],
    ['question' => 'Repository Pattern', 'answer' => 'Шаблон репозиторий', 'weight' => 0],
    ['question' => 'Dependency Injection', 'answer' => 'Внедрение зависимости', 'weight' => 0],
    ['question' => 'Inversion of Control', 'answer' => 'Инверсия управления', 'weight' => 0],
    ['question' => 'Single Responsibility Principle', 'answer' => 'Принцип единственной ответственности', 'weight' => 0],
    ['question' => 'Open/Closed Principle', 'answer' => 'Принцип открытости/закрытости', 'weight' => 0],
    ['question' => 'Liskov Substitution Principle', 'answer' => 'Принцип подстановки Лисков', 'weight' => 0],
    ['question' => 'Interface Segregation Principle', 'answer' => 'Принцип разделения интерфейсов', 'weight' => 0],
    ['question' => 'Dependency Inversion Principle', 'answer' => 'Принцип инверсии зависимостей', 'weight' => 0],

    ['question' => 'SOLID', 'answer' => 'SOLID - это принципы разработки программного обеспечения, следуя которым вы получите хороший код, который в дальнейшем будет хорошо масштабироваться и поддерживаться.', 'weight' => 0],
    ['question' => 'Single Responsibility Principle', 'answer' => 'Принцип единственной ответственности. Каждый класс должен иметь только одну зону ответственности.', 'weight' => 0],
    ['question' => 'Open Closed Principle', 'answer' => 'Принцип открытости-закрытости. Классы должны быть открыты для расширения, но закрыты для изменения.', 'weight' => 0],
    ['question' => 'Liskov Substitution Principle', 'answer' => 'Принцип подстановки Барбары Лисков. Должна быть возможность вместо родительского класса подставить любой его класс-наследник, при этом работа программы не должна измениться.', 'weight' => 0],
    ['question' => 'Interface Segregation Principle', 'answer' => 'Принцип разделения интерфейсов. Данный принцип обозначает, что не нужно заставлять класс реализовывать интерфейс, который не имеет к нему отношения.', 'weight' => 0],
    ['question' => 'Dependency Inversion Principle', 'answer' => 'Принцип инверсии зависимостей. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.', 'weight' => 0],


    ['question' => 'Основные паттерны проектирования', 'answer' => 'Конечно! Вот список основных паттернов проектирования с кратким объяснением каждого:', 'weight' => 0],
    ['question' => 'Singleton (Одиночка)', 'answer' => 'Проблема: Как создать класс, который будет иметь только один экземпляр на протяжении всего времени работы программы? Решение: Одиночка обеспечивает наличие одного экземпляра класса и предоставляет глобальную точку доступа к этому экземпляру. Например, если у вас есть класс для управления подключением к базе данных, Singleton гарантирует, что все части вашей программы используют одно и то же подключение.', 'weight' => 0],
    ['question' => 'Factory Method (Фабричный Метод)', 'answer' => 'Проблема: Как создать объект без указания точного класса создаваемого объекта? Решение: Фабричный метод предоставляет интерфейс для создания объектов в суперклассе, но позволяет подклассам изменять тип создаваемых объектов. Например, если у вас есть разные типы транспортных средств (машина, велосипед), фабричный метод может быть использован для создания нужного типа транспорта в зависимости от условий.', 'weight' => 0],
    ['question' => 'Abstract Factory (Абстрактная Фабрика)', 'answer' => 'Проблема: Как создать семейства связанных или зависимых объектов без указания их конкретных классов? Решение: Абстрактная фабрика предоставляет интерфейс для создания семейств взаимосвязанных объектов, что упрощает создание объектов, которые должны работать вместе. Например, если у вас есть GUI, который должен поддерживать разные операционные системы, абстрактная фабрика может создавать элементы интерфейса, специфичные для каждой ОС.', 'weight' => 0],
    ['question' => 'Builder (Строитель)', 'answer' => 'Проблема: Как создавать сложные объекты пошагово? Решение: Строитель разбивает создание сложного объекта на этапы, позволяя поэтапно строить объект. Это удобно, когда объект может быть создан с разными конфигурациями. Например, построение сложного объекта, такого как дом, может включать этапы для добавления фундамента, стен, крыши и т.д.', 'weight' => 0],
    ['question' => 'Prototype (Прототип)', 'answer' => 'Проблема: Как создать новый объект путем копирования существующего объекта? Решение: Прототип создает новый объект путем клонирования существующего. Это полезно, когда создание объекта дорого по ресурсам или когда вам нужно создать точную копию объекта. Например, если создание объекта требует больших вычислительных ресурсов, можно создать один объект и клонировать его для создания новых экземпляров.', 'weight' => 0],
    ['question' => 'Adapter (Адаптер)', 'answer' => 'Проблема: Как заставить несовместимые интерфейсы работать вместе? Решение: Адаптер позволяет классам с несовместимыми интерфейсами работать вместе, выступая в роли посредника. Например, если у вас есть старая библиотека для обработки данных, а новая библиотека требует другой формат данных, адаптер может преобразовать данные из старого формата в новый.', 'weight' => 0],
    ['question' => 'Bridge (Мост)', 'answer' => 'Проблема: Как разделить абстракцию и реализацию, чтобы они могли изменяться независимо друг от друга? Решение: Мост разделяет абстракцию и реализацию, что позволяет их изменять независимо. Например, если у вас есть графический интерфейс с различными платформами, мост может позволить вам изменять интерфейс без изменения его реализации.', 'weight' => 0],
    ['question' => 'Composite (Компоновщик)', 'answer' => 'Проблема: Как работать с объектами как с единичными, так и с их группами одинаково? Решение: Компоновщик позволяет объединить объекты в древовидную структуру для работы с ними как с одним объектом. Например, в системе графического интерфейса можно использовать компоновщик для группировки элементов интерфейса, таких как кнопки, чтобы они обрабатывались как один элемент.', 'weight' => 0],
    ['question' => 'Decorator (Декоратор)', 'answer' => 'Проблема: Как динамически добавлять новые функции к объекту без изменения его структуры? Решение: Декоратор оборачивает объект и добавляет новые функциональные возможности, оставаясь при этом совместимым с остальными объектами в системе. Например, вы можете декорировать базовый объект автомобиля различными функциями, такими как автоматическая коробка передач или система кондиционирования, не изменяя сам класс автомобиля.', 'weight' => 0],
    ['question' => 'Facade (Фасад)', 'answer' => 'Проблема: Как предоставить простой интерфейс для сложной подсистемы? Решение: Фасад предоставляет упрощенный интерфейс к сложной системе, скрывая её детали реализации. Например, в большой системе, такой как библиотека для работы с графикой, фасад может упростить работу с системой, предоставив простые методы для частых задач.', 'weight' => 0],
    ['question' => 'Proxy (Заместитель)', 'answer' => 'Проблема: Как предоставить объекту-заместителю возможность контролировать доступ к другому объекту? Решение: Заместитель предоставляет доступ к другому объекту, контролируя его. Например, прокси может быть использован для ленивой инициализации объектов, контроля доступа или для выполнения дополнительных операций перед доступом к реальному объекту.', 'weight' => 0],
    ['question' => 'Observer (Наблюдатель)', 'answer' => 'Проблема: Как обеспечить автоматическое уведомление объектов о изменениях в другом объекте? Решение: Наблюдатель позволяет объектам подписываться на события и получать уведомления об изменениях. Например, в системе уведомлений, когда состояние объекта изменяется, все наблюдатели получают уведомление об этом изменении.', 'weight' => 0],
    ['question' => 'Strategy (Стратегия)', 'answer' => 'Проблема: Как выбрать алгоритм на этапе выполнения, а не на этапе компиляции? Решение: Стратегия позволяет определять семейство алгоритмов, инкапсулировать их и делать их взаимозаменяемыми. Например, если у вас есть разные способы сортировки данных, стратегия позволяет вам выбрать нужный способ сортировки во время выполнения программы.', 'weight' => 0],
    ['question' => 'State (Состояние)', 'answer' => 'Проблема: Как управлять состоянием объекта так, чтобы его поведение изменялось в зависимости от состояния? Решение: Состояние позволяет объекту изменять свое поведение при изменении его внутреннего состояния. Например, в автомате с продажей билетов поведение будет зависеть от того, есть ли монеты в автомате или билет уже выдан.', 'weight' => 0],
    ['question' => 'Command (Команда)', 'answer' => 'Проблема: Как инкапсулировать запрос как объект, позволяя передавать его как параметр? Решение: Команда инкапсулирует запрос в виде объекта, что позволяет параметризовать методы с помощью действий. Например, в системе выполнения задач, команда может представлять собой операцию, которую можно передать и выполнить позже.', 'weight' => 0],
    ['question' => 'Преимущества паттернов проектирования', 'answer' => 'Эти паттерны помогают решать типичные проблемы проектирования программного обеспечения, улучшая архитектуру, упрощая поддержку и расширение системы.', 'weight' => 0],



];
